# [Функции для работы с сокетами::](https://rsdn.org/article/unix/sockets.xml)
## Сокет и его аттрибуты

```c
int socket(int domain, int type, int protocol);
```
>`domain` - тип адресов, перечисление. Варианты - `AF_UNIX`, `AF_INET` (AF - Adress family).

>`type` - тип соединения. Варианты - `SOCK_STREAM`, `SOCK_DGRAM`, `SOCK_RAW`.

>`protocol` - конкретный вариант протокола, при получении 0 выбирается протокол, по  умолчанию соответствующий типу соединения.


До начала передачи данных сокет нужно связать с адресом.

```c
int bind(int sockfd, struct sockaddr *addr, int addrlen);
```
> `sockfd` - дескриптор сокета.

> `addrlen` - длина структуры, хранящей информацию об адресе.
```c
struct sockaddr{
    unsigned sa_family;    // Семейство адресов AF_xxx
    char     sa_data[14];  // 14 байтов для хранения адреса
}
```
>`sa_family` - то же самое, что и `domain`.

Чтобы не крутить кульбиты с обработкой `char*`, интерпретация которого зависит от того, какому семейству принадлежит адрес, можно использовать альтернативные структуры вида `sockaddr_XX`:

```c
struct sockaddr_in{
    short int          sin_family;   // Семейство адресов
    unsigned short int sin_port;     // Номер порта
    struct in_addr     sin_addr;     // IP - адрес
    unsigned char      sin_zero[8];  // Дополнение для соответствия размеров
};
```

```c
struct in_addr{
    unsigned long s_addr;
};
```


## Уствновка соединения со стороны сервера

Для создания очереди запросов и включения режима ожидания используется функция `listen` из `sys/socket.h`
```c
int listen(int sockfd, int backlog);
```

>`sockfd` - дескриптор сокета.

>`backlog` - размер очереди запросов. Если очередь заполнена - все последующие запросы будут игнорироваться.

Когда сервер готов обслужить очередной запрос - вызывается функция `accept`

```c
int accept(int sockfd, void* addr, int* addrlen);
```

`accept` создает для общения с клиентом новый сокет и возвращает его дескриптор.

>`sockfd` - слушающий сокет. После вызова он так и остается в слушающем состоянии и может принимать соединения и дальше.

>`addr` - структура, в которую записывается адрес сокета клиента, который установил соединение.

>`addrlen` - размер структуры `addr`.

Полученный от `accept` новый сокет связан с тем же адресом, что и слушающий сокет.

## Установка соединения со стороны клиента

```c
int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
```

>`sockfd` - сокет, который будет использоваться для обмена данными.

>`serv_addr` - структура для хранения адреса сервера.

`connect` сама привяжет сокет к адресу, подберет свободный порт, так что можно ни о чем не париться. Хотя, если очень хочется, использование `bind` перед `connect` позволит установить нужный порт.

## Обмен данными

`send` и `recv` наши лучшие друзья для обмена данными.

```c
int send(int sockfd, const void* msg, int len, int flags);
```
Про эту функцию главное запомнить, что она возвращает действительное количество отправленых байт, то есть может послать не весь буфер, а только, например, 42.

Для того, чтобы отправить все байты из буфера придется городить что - то в таком духе:
```c
int sendall(int s, char* buf, int len, int flags){
    int total = 0;
    int n;
    while(total < len){
        n = send(s, buf + total, len - total, flags);
        if(n == -1) break;
        total += n;
    }
    return (n == -1 ? -1 : total);
}
```
Здесь `send` будет вызываться до тех пор, пока не отправит весь буфер в пункт назначения, чего нам, собственно, и надо.

Чтобы считать данные из сокета будем пользовать `recv`:
```c
int recv(int sockfd, void* buf, int len, int flags);
```

Эта функция возвращает количество байт, записаных в буфер, либо `0`, если соединение было разорвано.

## Закрытие сокета

Используется функция с говорящим названием `close`, принимающая дескриптор сокета (просто целое число).
Что говорить, когда нечего говорить?

>`GLHF`